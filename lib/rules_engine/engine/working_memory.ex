defmodule RulesEngine.Engine.WorkingMemory do
  @moduledoc """
  Working Memory (WM) implementation for storing and indexing facts.

  Maintains facts by ID and type, with support for partitioning and
  efficient lookup patterns. Handles assert/modify/retract operations
  and propagates changes through the RETE network.
  """

  defstruct [
    # %{id => fact}
    :facts,
    # %{type => MapSet[id]}
    :type_index,
    # %{memory_id => AlphaMemory}
    :alpha_memories,
    # %{memory_id => BetaMemory}
    :beta_memories,
    # %{node_id => TokenTable}
    :token_tables,
    :partition_count
  ]

  @type fact :: map()
  @type fact_id :: term()
  @type fact_type :: atom() | binary()

  @type t :: %__MODULE__{
          facts: %{fact_id() => fact()},
          type_index: %{fact_type() => MapSet.t()},
          alpha_memories: %{term() => RulesEngine.Engine.AlphaMemory.t()},
          beta_memories: %{term() => RulesEngine.Engine.BetaMemory.t()},
          token_tables: %{term() => RulesEngine.Engine.TokenTable.t()},
          partition_count: pos_integer()
        }

  @doc """
  Create new working memory with specified partition count.
  """
  @spec new(partition_count :: pos_integer()) :: t()
  def new(partition_count \\ 1) do
    %__MODULE__{
      facts: %{},
      type_index: %{},
      alpha_memories: %{},
      beta_memories: %{},
      token_tables: %{},
      partition_count: partition_count
    }
  end

  @doc """
  Calculate approximate memory usage of working memory structures.
  """
  @spec memory_usage(t()) :: non_neg_integer()
  def memory_usage(%__MODULE__{} = wm) do
    facts_memory = estimate_facts_memory(wm.facts)
    index_memory = estimate_index_memory(wm.type_index)
    alpha_memory = estimate_alpha_memory(wm.alpha_memories)
    beta_memory = estimate_beta_memory(wm.beta_memories)
    token_memory = estimate_token_memory(wm.token_tables)

    facts_memory + index_memory + alpha_memory + beta_memory + token_memory
  end

  @doc """
  Get the size of working memory (number of facts).
  """
  @spec size(t()) :: non_neg_integer()
  def size(working_memory) do
    map_size(working_memory.facts)
  end

  @doc """
  Assert facts into working memory and propagate through network.
  """
  @spec assert_facts(state :: map(), facts :: [fact()]) :: {map(), [fact()]}
  def assert_facts(state, facts) do
    wm = state.working_memory

    # Add facts to working memory
    {new_wm, _} =
      Enum.reduce(facts, {wm, []}, fn fact, {wm_acc, derived_acc} ->
        {updated_wm, derived} = assert_fact(wm_acc, fact)
        {updated_wm, derived_acc ++ derived}
      end)

    new_state = %{state | working_memory: new_wm}

    # Propagate through alpha network
    updated_state = propagate_facts_through_alpha_network(new_state, facts)

    # No derived facts yet (will be generated by beta network)
    {updated_state, []}
  end

  @doc """
  Retract facts from working memory by ID.
  """
  @spec retract_facts(state :: map(), ids :: [fact_id()]) :: {map(), [fact()]}
  def retract_facts(state, ids) do
    wm = state.working_memory

    # Collect facts being retracted
    retracted =
      Enum.map(ids, &Map.get(wm.facts, &1))
      |> Enum.filter(&(&1 != nil))

    # Remove from working memory
    new_wm = Enum.reduce(ids, wm, &retract_fact(&2, &1))

    new_state = %{state | working_memory: new_wm}

    # Propagate retractions through network
    updated_state = propagate_retractions_through_network(new_state, ids)

    {updated_state, retracted}
  end

  @doc """
  Get facts by type.
  """
  @spec facts_by_type(t(), fact_type()) :: [fact()]
  def facts_by_type(%__MODULE__{} = wm, type) do
    case Map.get(wm.type_index, type) do
      nil ->
        []

      ids ->
        ids
        |> Enum.map(&Map.get(wm.facts, &1))
        |> Enum.filter(&(&1 != nil))
    end
  end

  @doc """
  Get fact by ID.
  """
  @spec get_fact(t(), fact_id()) :: fact() | nil
  def get_fact(%__MODULE__{} = wm, id) do
    Map.get(wm.facts, id)
  end

  @doc """
  Count total facts in working memory.
  """
  @spec count_facts(t()) :: non_neg_integer()
  def count_facts(%__MODULE__{} = wm) do
    map_size(wm.facts)
  end

  @doc """
  List all fact types with counts.
  """
  @spec type_counts(t()) :: %{fact_type() => non_neg_integer()}
  def type_counts(%__MODULE__{} = wm) do
    wm.type_index
    |> Enum.map(fn {type, ids} -> {type, MapSet.size(ids)} end)
    |> Enum.into(%{})
  end

  @doc """
  Create snapshot of working memory state.
  """
  @spec snapshot(t()) :: map()
  def snapshot(%__MODULE__{} = wm) do
    %{
      facts: wm.facts,
      type_counts: type_counts(wm),
      total_facts: count_facts(wm),
      alpha_memory_count: map_size(wm.alpha_memories),
      beta_memory_count: map_size(wm.beta_memories)
    }
  end

  # Private Implementation

  defp assert_fact(%__MODULE__{} = wm, fact) do
    id = Map.get(fact, :id)
    type = Map.get(fact, :type)

    unless id && type do
      raise ArgumentError, "Fact must have :id and :type fields: #{inspect(fact)}"
    end

    # Add to facts map
    new_facts = Map.put(wm.facts, id, fact)

    # Update type index
    new_type_index = Map.update(wm.type_index, type, MapSet.new([id]), &MapSet.put(&1, id))

    new_wm = %{wm | facts: new_facts, type_index: new_type_index}

    # Propagate through alpha memories - would trigger matching
    derived_facts = propagate_to_alpha_memories(new_wm, id, fact)

    {new_wm, derived_facts}
  end

  # Private propagation functions

  defp propagate_facts_through_alpha_network(state, _facts) do
    # Update alpha memories with new facts
    # For now, return state unchanged - will be implemented when alpha network is active
    state
  end

  defp propagate_retractions_through_network(state, _fact_ids) do
    # Remove facts from alpha and beta memories, update activations
    # For now, return state unchanged - will be implemented when network is active
    state
  end

  defp propagate_to_alpha_memories(_wm, _fact_id, _fact) do
    # Match fact against alpha memory patterns and propagate to beta network
    # For now, return no derived facts - will be implemented when network is active
    []
  end

  defp retract_fact(%__MODULE__{} = wm, id) do
    case Map.get(wm.facts, id) do
      nil ->
        # Fact doesn't exist, no-op
        wm

      fact ->
        type = Map.get(fact, :type)

        # Remove from facts map
        new_facts = Map.delete(wm.facts, id)

        # Update type index
        new_type_index = Map.update(wm.type_index, type, MapSet.new(), &MapSet.delete(&1, id))

        # Clean up empty type entries
        new_type_index =
          if MapSet.size(Map.get(new_type_index, type, MapSet.new())) == 0 do
            Map.delete(new_type_index, type)
          else
            new_type_index
          end

        %{wm | facts: new_facts, type_index: new_type_index}
    end
  end

  # Memory estimation helper functions

  defp estimate_facts_memory(facts) do
    facts
    |> Enum.reduce(0, fn {_id, fact}, acc ->
      fact_size = :erlang.external_size(fact)
      acc + fact_size
    end)
  end

  defp estimate_index_memory(type_index) do
    type_index
    |> Enum.reduce(0, fn {type, id_set}, acc ->
      type_size = :erlang.external_size(type)
      # Estimate 8 bytes per ID
      set_size = MapSet.size(id_set) * 8
      acc + type_size + set_size
    end)
  end

  defp estimate_alpha_memory(alpha_memories) do
    # Estimate 100 bytes per alpha memory
    map_size(alpha_memories) * 100
  end

  defp estimate_beta_memory(beta_memories) do
    # Estimate 200 bytes per beta memory
    map_size(beta_memories) * 200
  end

  defp estimate_token_memory(token_tables) do
    # Estimate 150 bytes per token table
    map_size(token_tables) * 150
  end
end
